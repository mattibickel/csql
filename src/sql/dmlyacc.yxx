%{
#include <CSql.h>
#include <stdlib.h>
#include "Parser.h"

class Predicate;
ParsedData *parsedData;
extern char yytext[];
int yylex( void );
void yyerror(const char* Msg);
%}


%union
{
   char *stringval;
   void *predicate;
}

%left OR 
%left AND
%token <stringval> STRING FIELD NUMBER_STRING BINARY_STRING DOUBLE OPERATOR PARAMETER
%token <stringval> SELECT FROM WHERE BETWEEN IN AND OR NOT
%token <stringval> STAR
%token <stringval> INSERT INTO VALUES
%token <stringval> DELETE UPDATE SET NULL_VALUE
%token <stringval> CREATE TABLE PRIMARY KEY DEFAULT INDEX ON HASH TREE UNIQUE DROP
%token <stringval> INT_TYPE LONG_TYPE SHORT_TYPE DOUBLE_TYPE TIMESTAMP_TYPE DATE_TYPE CHAR_TYPE TIME_TYPE BIGINT_TYPE FLOAT_TYPE TINYINT_TYPE BINARY_TYPE
%token <stringval> MIN MAX AVG SUM COUNT GROUP BY
%token ';' ',' '(' ')'
%type <stringval> ident field value not_opt
%type <predicate> conditions condition 
%%
command:  select_statement { YYACCEPT; }
        | insert_statement { YYACCEPT; }
        | delete_statement { YYACCEPT; }
        | update_statement { YYACCEPT; }
        | ddl_statement { YYACCEPT; }
        ;
        
select_statement: SELECT field_list FROM ident where_clause_opt group_by_opt semicolon_opt
	{
            parsedData->setStmtType(SelectStatement);
            parsedData->setTableName($4); 
            free($4);
        }
        ;

field_list: field_list field_list_L
        | field 
        ;
field_list_L: ',' field
        ;
        
insert_statement: INSERT INTO ident field_list_opt VALUES '(' value_list ')' semicolon_opt
        {
            parsedData->setStmtType(InsertStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        ;

field_list_opt:
        | '(' field_list ')'
        ;

value_list: value_list value_list_L
        | value
	{
            parsedData->insertValue((char*)$1);
            free($1);
        }
        ;
value_list_L: ',' value 
	{
            parsedData->insertValue((char*)$2);
            free($2);
        }
        ;
        
invalue_list: invalue_list invalue_list_L
        | value
	{
            parsedData->insertInValue((char*)$1);
            free($1);
        }
        ;
invalue_list_L: ',' value 
	{
            parsedData->insertInValue((char*)$2);
            free($2);
        }
        ;
        
delete_statement: DELETE FROM ident where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(DeleteStatement);
            parsedData->setTableName($3); 
            free($3);
	}
        ;
        
update_statement: UPDATE ident SET assign_list where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(UpdateStatement);
            parsedData->setTableName($2); 
            free( $2 );
	}
        ;

semicolon_opt: ';'
        |
        ;

assign_list: assign_list assign_list_L
        | assign_stmt
        ;

assign_list_L: ',' assign_stmt
        ;
assign_stmt: ident OPERATOR value 
        { 
            parsedData->insertUpdateValue( (char*) $1, (char*) $3);
            free( $1 ); free($2);free( $3 ); 
        }
        ;
 
where_clause_opt:  WHERE conditions
        |
        ;
group_by_opt:  GROUP BY group_field_list
        |
        ;
group_field_list: group_field_list group_field_list_L
        | group_field 
        ;
group_field_list_L: ',' group_field
        ;
group_field:   ident
        {
            parsedData->insertGroupField((char*)$1);
            free( $1 );
        }
        ;
conditions: conditions OR conditions
	{
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpOr, (Predicate*) $3);
            parsedData->setCondition((Predicate*)pred);
            $$= pred;

        }
        | conditions AND conditions
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpAnd, (Predicate*) $3);
            parsedData->setCondition((Predicate*)pred);
            $$= pred;
        }
        | '(' conditions ')' { $$=$2; }
        | NOT '(' conditions ')'
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $3, OpNot, NULL);
            parsedData->setCondition((Predicate*)pred);
            $$= pred;

        }
        | not_opt condition
        {
            if( $1 == (char*) 1 )
            {
                Predicate *pred;
                pred = parsedData->insertPredicate((Predicate*) $2, OpNot, NULL);
                parsedData->setCondition((Predicate*)pred);
                $$= pred;
            }
            else
            {
                parsedData->setCondition((Predicate*)$2);
                $$=$2;
            }
        }
        ;
condition: ident OPERATOR value 
	{
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
			bool opLike = false;
            if (op == OpLike) {
                char *c = (char *)$3;
                while (*c != '\0') {
                    if (*c == '_') *c = '?';
                    else if(*c == '%') *c = '*';
                    c++;
			    }
				opLike = true;
            }
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$3, opLike);
            pred = parsedData->insertPredicate((char*) $1, op, ptr);
            free( $1 ); free($2); free( $3 ); 
            $$=pred;
        }
        | ident OPERATOR ident
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            Predicate *pred;
            pred = parsedData->insertPredicate((char*) $1, op, (char*) $3);
            free( $1 ); free($2); free( $3 );
            $$=pred;
        }

        | ident not_opt BETWEEN value AND value
        {
            void **ptr1 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$4);
            void **ptr2 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$6);
            Predicate *pred1, *pred2, *pred3, *finalPred;
            pred1 = parsedData->insertPredicate((char*) $1, OpGreaterThanEquals, ptr1);
            pred2 = parsedData->insertPredicate((char*) $1, OpLessThanEquals, ptr2);
            finalPred = parsedData->insertPredicate(pred1, OpAnd, pred2);
            if( $2 == (char*) 1 )
                finalPred = parsedData->insertPredicate(finalPred, OpNot, NULL);
            free( $1 );  free( $4 );  free( $6 );
            $$= finalPred;
        }
        | ident not_opt IN '(' invalue_list ')'
        {
            ListIterator valIter = parsedData->getInValueList().getIterator();
            FieldValue *value1, *value2;
            Predicate *pred1, *pred2, *finalPred;
            void **ptr1, **ptr2;
            if (valIter.hasElement()) {
               value1 = (FieldValue*) valIter.nextElement();
               ptr1 = parsedData->insertCondValueAndGetPtr((char*)$1, value1->parsedString);
               pred1 = parsedData->insertPredicate((char*) $1, OpEquals, ptr1);
               finalPred=pred1;
            }
            while (valIter.hasElement()) {
               value2 = (FieldValue*) valIter.nextElement();
               ptr2 = parsedData->insertCondValueAndGetPtr((char*)$1, value2->parsedString);
               pred2 = parsedData->insertPredicate((char*) $1, OpEquals, ptr2);
               finalPred = parsedData->insertPredicate(pred1, OpOr, pred2);
               pred1= finalPred;     
            }
            if( $2 == (char*)1)
                finalPred = parsedData->insertPredicate(finalPred, OpNot, NULL);

            free( $1 );  
            $$= finalPred;
        }
        ;
not_opt: NOT
	{ $$=(char*) 1;
	}
	| 
	{ $$=(char*) 0; }
	;
field:   ident
        {
            parsedData->insertField((char*)$1);
            free( $1 );
            
        }
        | MIN  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_MIN);
            free( $1 );
        }
        | MAX  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_MAX);
            free( $1 );
        }
        | SUM  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_SUM);
            free( $1 );
        }
        | AVG  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_AVG);
            free( $1 );
        }
        | COUNT  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_COUNT);
            free( $1 );
        }
        | COUNT  '(' STAR ')'
        { 
            parsedData->insertField("*", AGG_COUNT);
            free( $1 );
        }
        | STAR
        { 
            parsedData->insertField((char*)$1);
            free( $1 );
        }
        ;
ident:    FIELD { $$ = $1; }
        ;
value:    STRING { $$ = $1; }
        | NUMBER_STRING { $$ = $1; }
        | BINARY_STRING { $$ = $1; }
        | DOUBLE { $$ = $1; }
        | PARAMETER { $$ = $1; }
        | NULL_VALUE { $$ = (char*) 0; }
        ;

ddl_statement: CREATE TABLE ident '(' create_defn_list_con ')' semicolon_opt
        {
            parsedData->setStmtType(CreateTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | CREATE INDEX ident ON ident '(' field_list ')' opt_constr_type opt_ind_type  semicolon_opt
        {
            parsedData->setStmtType(CreateIndexStatement);
            parsedData->setIndexName($3); 
            parsedData->setTableName($5); 
            free($3);
            free($5);
        }
        | DROP TABLE ident
        {
            parsedData->setStmtType(DropTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | DROP INDEX ident
        {
            parsedData->setStmtType(DropIndexStatement);
            parsedData->setIndexName($3); 
            free($3);
        }
        ;
opt_ind_type:
        | HASH  opt_constr_type
        {
            parsedData->setIndexType(hashIndex);
        }
        | TREE  opt_constr_type
        {
            parsedData->setIndexType(treeIndex);
        }
        |
        {
            parsedData->setIndexType(hashIndex);
        }
        ;
opt_constr_type:
        | UNIQUE 
        {
            parsedData->setUnique(true);
        }
        | PRIMARY 
        {
            parsedData->setUnique(true);
            parsedData->setPrimary(true);
        }
        |
        {
            parsedData->setUnique(false);
            parsedData->setPrimary(false);
        }
        ;
create_defn_list_con:create_defn_list
	|create_defn_list ',' constraint_defn
	;
create_defn_list: create_defn_list create_defn_list_L
        | create_defn
        ;

create_defn_list_L: ',' create_defn
        ;

create_defn: field_defn
        {
            parsedData->insertFldDef();
        }
        ;

field_defn: field_name field_type size_opt null_expr_opt default_expr_opt
        ;

field_name: ident
        {
            parsedData->setFldName($1);
            free($1);
        }
size_opt:
        | '(' NUMBER_STRING ')'
        {
            parsedData->setFldLength(atoi($2)+1);
            free($2);
        }
        ;

default_expr_opt:
        | DEFAULT value
        {
            parsedData->setDefaultValue($2);
            free($2);
        }
        ;

null_expr_opt:
        | NOT NULL_VALUE
        {
            parsedData->setFldNotNull(true);
        }
        ;
constraint_defn: primary_key_constraint
        ;

primary_key_constraint: PRIMARY KEY '(' field_list ')'
        {
           parsedData->setPrimary(true);
        }
        ;

field_type: INT_TYPE
        {
            parsedData->setFldType(typeInt);
        }
        | LONG_TYPE
        {
            parsedData->setFldType(typeLong);
        }
        | SHORT_TYPE
        {
            parsedData->setFldType(typeShort);
        }
        | BIGINT_TYPE
        {
            parsedData->setFldType(typeLongLong);
        }
        | TINYINT_TYPE
        {
            parsedData->setFldType(typeByteInt);
        }
        | FLOAT_TYPE
        {
            parsedData->setFldType(typeFloat);
        }
        | DOUBLE_TYPE
        {
            parsedData->setFldType(typeDouble);
        }
        ;
        | DATE_TYPE
        {
            parsedData->setFldType(typeDate);
        }
        ;
        | TIME_TYPE
        {
            parsedData->setFldType(typeTime);
        }
        ;
        | TIMESTAMP_TYPE
        {
            parsedData->setFldType(typeTimeStamp);
        }
        ;
        | CHAR_TYPE
        {
            parsedData->setFldType(typeString);
            parsedData->setFldLength(2);
        }
        ;
        | BINARY_TYPE
        {
            parsedData->setFldType(typeBinary);
            parsedData->setFldLength(1);
        }
        ;
%%

extern int lexEof;
void yyerror(const char* Msg) { 
    if( lexEof == 0 )
        fprintf(stderr, "[Parser: %s] %s\n", Msg, yytext);

    return;
}
