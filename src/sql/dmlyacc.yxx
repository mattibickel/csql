%{
#include <CSql.h>
#include <stdlib.h>
#include "Parser.h"

class Predicate;
ParsedData *parsedData;
extern char yytext[];
int yylex( void );
void yyerror(const char* Msg);
%}


%union
{
   char *stringval;
   void *predicate;
   void *Expression;
   void *FunctionType;
}

%left OR 
%left AND
%left '+' '-'
%left '*' '/' '%'
%nonassoc UMINUS
%token <stringval> STRING FIELD NUMBER_STRING BINARY_STRING DOUBLE OPERATOR PARAMETER ALLTABLE DESCRIBE PRIMARYINFO AUTO_INCREMENT GETCATALOGS GETDATATYPES GETTABLETYPES IMPORTEDKEY EXPORTEDKEY
%token <stringval> SELECT FROM WHERE BETWEEN IN AND OR NOT AS LIMIT OFFSET INNER OUTER CROSS JOIN LEFT IS
%token <stringval> INSERT INTO VALUES EXPLAIN PLAN
%token <stringval> DELETE UPDATE SET NULL_VALUE
%token <stringval> CREATE TABLE PRIMARY KEY DEFAULT INDEX ON HASH TREE UNIQUE DROP SIZE FOREIGN REFERENCES COMPACT TRUNCATE 
%token <stringval> CACHE CONDITION FIELDLIST PK DIRECT DSN UNCACHE NOSCHEMA
%token <stringval> INT_TYPE LONG_TYPE SHORT_TYPE DOUBLE_TYPE TIMESTAMP_TYPE DATE_TYPE CHAR_TYPE TIME_TYPE BIGINT_TYPE FLOAT_TYPE TINYINT_TYPE BINARY_TYPE VARCHAR_TYPE
%token <stringval> DATE_DIFF DATE_ADD DATE_SUB HOUR MINUTE SECOND YEAR MONTH DAY INTERVAL TIME_DIFF TIME_ADD TIME_SUB TIMESTAMP_DIFF TIMESTAMP_ADD TIMESTAMP_SUB EXTRACT 
%token <stringval> USER PASSWORD ALTER FLUSH ADD COLUMN MODIFY RENAME TO
%token <stringval> MIN MAX AVG SUM COUNT GROUP BY HAVING ORDER ASC DESC DISTINCT
%token ';' ',' '(' ')'
%type <stringval> ident field value not_opt doub_value num_value 
/*%type <stringval> foreign_key_constraint foreign_key_create foreign_key_constraint_L*/
%type <predicate> conditions condition hconditions hcondition 
%type <Expression> stmt_exp atom function_opt
%type <FunctionType> date_opt time_opt datetime_opt
%%
command:  select_statement { YYACCEPT; }
        | insert_statement { YYACCEPT; }
        | delete_statement { YYACCEPT; }
        | update_statement { YYACCEPT; }
        | ddl_statement { YYACCEPT; }
        | internal_statement { YYACCEPT; }
        | cache_statement { YYACCEPT; }
        | copy_table_statement { YYACCEPT; }
        | user_manager_statement { YYACCEPT; }
	| management_statement { YYACCEPT; }
	| alter_statement { YYACCEPT; }
        | other {YYACCEPT;}
        ;
alter_statement: ALTER TABLE ident ADD '(' create_defn_list_con ')' semicolon_opt
	{
            parsedData->setStmtType(AlterStatement);
            parsedData->setAlterType(ALTERADD);
            parsedData->setTableName($3);
            free($3); 
	}
	| ALTER TABLE ident DROP COLUMN ident semicolon_opt
	{
            parsedData->setStmtType(AlterStatement);
            parsedData->setAlterType(ALTERDROP);
            parsedData->setTableName($3);
            parsedData->setIndexName($6); 
            free($3);
	}
	| ALTER TABLE ident MODIFY '(' create_defn ')' semicolon_opt
	{
            printf(" Not Implemented\n");
            free($3);
            YYABORT;
	}
	| RENAME TABLE ident TO ident semicolon_opt
	{
            parsedData->setStmtType(AlterStatement);
            parsedData->setAlterType(ALTERTABLERENAME);
            parsedData->setTableName($3);
            parsedData->setIndexName($5); 
            free($3); free($5);

	}
	| ALTER TABLE ident RENAME COLUMN ident TO ident semicolon_opt
        {
            parsedData->setStmtType(AlterStatement);
            parsedData->setAlterType(ALTERFIELDRENAME);
            parsedData->setTableName($3);
            parsedData->setIndexName($6);
            parsedData->setPKTableName($8);
            free($3); free($5); free($8);
        }
	;
management_statement: FLUSH CACHE semicolon_opt
	{
           parsedData->setStmtType(MgmtStatement);
	}
	;
user_manager_statement: CREATE USER ident PASSWORD STRING semicolon_opt
	{
            parsedData->setStmtType(UserStatement);
            parsedData->createUserNode((char*)$3,(char*)$5);
            free($3);
            free($5);
	}
        |DROP USER ident semicolon_opt
        {
            parsedData->setStmtType(UserStatement);
            parsedData->dropUserNode((char*)$3);
            free($3);
        }
        | ALTER USER ident SET PASSWORD STRING semicolon_opt
	{
            parsedData->setStmtType(UserStatement);
            parsedData->alterUserNode((char*)$3,(char*)$6);
            free($3);
            free($6);
	}
        ;
copy_table_statement: CREATE TABLE ident AS SELECT opt_distinct field_list FROM table_list where_clause_opt group_by_opt having_opt order_by_opt limit_opt semicolon_opt
        {
            parsedData->setStmtType(CopyTableStatement);
            parsedData->setPKTableName($3);
            parsedData->setCreateTbl();
            free($3);
        }
        | INSERT  INTO ident AS SELECT opt_distinct field_list FROM table_list where_clause_opt group_by_opt having_opt order_by_opt limit_opt semicolon_opt
        {
            parsedData->setStmtType(CopyTableStatement);
            parsedData->setPKTableName($3);
            free($3);
        }
        ;
internal_statement: COMPACT TABLE ident
        {
            parsedData->setStmtType(CompactTableStatement);
            parsedData->setTableName($3);
            free($3);
        }
        ;
other: ALLTABLE
	{
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetTables);
	}
        | DESCRIBE table 
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetColumns);
        }
        | DESCRIBE INDEX table
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetIndexes);
                   
        }
        | PRIMARYINFO table
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetPriIndex);
        }
        | GETCATALOGS
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetCatalogs);
        }
        | GETTABLETYPES
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetTableType);
        }
        | GETDATATYPES 
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetDataType);
        }
	| IMPORTEDKEY table
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetImportKey);
        }
        | EXPORTEDKEY table
        {
            parsedData->setStmtType(MetaStatement);
            parsedData->setResultSetPlan(GetExportKey);
        }
        ;
select_statement: opt_explain SELECT opt_distinct field_list FROM table_list where_clause_opt group_by_opt having_opt order_by_opt limit_opt semicolon_opt
	{
            parsedData->setStmtType(SelectStatement);
            parsedData->setCacheWorthy(true);
        }
        ;
opt_explain: EXPLAIN PLAN
	{
           parsedData->setExplain();
	}
	|
	;
opt_distinct: DISTINCT 
        { 
            parsedData->setDistinct();
        }
        |
        ;
field_list: field_list field_list_L
        | field_with_as
        ;
field_list_L: ',' field_with_as 
        ;
field_with_as: field
	| field AS ident
        {
            parsedData->insertFieldAlias((char*)$3);
            free((char*)$3);
        }
	;
table_list: table_list table_list_L
        | table 
        | table join_exp
        ;
join_exp: INNER opt_join table ON conditions join_exp
        {
           parsedData->insertJoinType(INNER_JOIN);

           Condition *cond = parsedData->getCondition();
           Predicate *pred = cond->getPredicate();
           if (pred == NULL) parsedData->setCondition((Predicate*)$5);
           else {
                Predicate *newPred;
                newPred = parsedData->insertPredicate(pred, OpAnd, (Predicate*)$5);
                parsedData->setCondition(newPred);
           }

        }
        | LEFT opt_outer opt_join table ON conditions join_exp
        {
           parsedData->insertJoinType(LEFT_JOIN);
           Condition *cond = parsedData->getCondition();
           Predicate *pred = cond->getPredicate();
           if (pred == NULL) parsedData->setCondition((Predicate*)$6);
           else {
                Predicate *newPred;
                newPred = parsedData->insertPredicate(pred, OpAnd, (Predicate*)$6);
                parsedData->setCondition(newPred);
           }
        }
        | CROSS opt_join table join_exp
        {
            parsedData->insertJoinType(INNER_JOIN);
        }
        |
        ;
opt_outer: 
       |OUTER
       ;
opt_join: 
       |JOIN
       ;
table_list_L: ',' table
        {
            parsedData->insertJoinType(INNER_JOIN);
        }
        ;
        
insert_statement: INSERT INTO ident field_list_opt VALUES '(' value_list ')' semicolon_opt
        {
            parsedData->setStmtType(InsertStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        ;

field_list_opt:
        | '(' field_list ')'
        ;

value_list: value_list value_list_L
        | value
	{
            parsedData->insertValue((char*)$1);
            free($1);
        }
        ;
value_list_L: ',' value 
	{
            parsedData->insertValue((char*)$2);
            free($2);
        }
        ;
        
invalue_list: invalue_list invalue_list_L
        | value
	{
            parsedData->insertInValue((char*)$1);
            free($1);
        }
        ;
invalue_list_L: ',' value 
	{
            parsedData->insertInValue((char*)$2);
            free($2);
        }
        ;
        
delete_statement: DELETE FROM ident where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(DeleteStatement);
            parsedData->setTableName($3); 
            free($3);
	}
        ;
        
update_statement: UPDATE ident SET assign_list where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(UpdateStatement);
            parsedData->setTableName($2); 
            free( $2 );
	}
        ;

semicolon_opt: ';'
        |
        ;

assign_list: assign_list assign_list_L
        | assign_stmt
        ;

assign_list_L: ',' assign_stmt
        ;
assign_stmt: ident  OPERATOR stmt_exp
        {
           parsedData->insertUpdateExpression( (char*) $1, (Expression* ) $3);
           free( $1 ); free($2);
        }
        | ident OPERATOR value 
        { 
            parsedData->insertUpdateValue( (char*) $1, (char*) $3);
            free( $1 ); free($2);free( $3 ); 
        }
        | ident OPERATOR NULL_VALUE 
        {
            parsedData->insertUpdateValue( (char*) $1, (char*) $3);
            free( $1 ); free($2);free( $3 );
        }
        ; 
stmt_exp: stmt_exp '/' stmt_exp
        {
            Expression* exp;
            exp=parsedData->insertExpression((Expression *)$1, division, (Expression *)$3);
            $$=exp;
        } 
        | stmt_exp '%' stmt_exp
        {
            Expression* exp;
            exp=parsedData->insertExpression((Expression *)$1, modulus, (Expression *)$3);
            $$=exp;
        }
        | stmt_exp '*' stmt_exp
        {
            Expression* exp;
            exp=parsedData->insertExpression((Expression *)$1, multiplication, (Expression *)$3);
            $$=exp;
        }
        | stmt_exp '+' stmt_exp
        {
            Expression* exp;
            exp=parsedData->insertExpression((Expression *)$1, addition, (Expression *)$3);
            $$=exp;
        }
        | stmt_exp '-' stmt_exp
        {
            Expression* exp;
            exp=parsedData->insertExpression((Expression *)$1, subtraction, (Expression *)$3);
            $$=exp;
        }
        | '(' stmt_exp ')'
        {
            $$=$2;
        }
        | '-' stmt_exp %prec UMINUS
        {
            $$ = $2;
        }
        | '+' stmt_exp %prec UMINUS
        {
            $$ = $2;
        }
        | function_opt
        | atom
        ;
function_opt: DATE_DIFF '(' atom ',' atom ')'
        {
              Expression* exp;
              parsedData->setFunctionType(DATEDIFF);
              exp=parsedData->insertExpression((Expression *)$3, DATEDIFF, (Expression *)$5);
            $$=exp;
        }
	| DATE_ADD '(' atom  INTERVAL atom date_opt ')'
	{
	     Expression* exp;
             parsedData->setFunctionType((*(FunctionType *)$6));
             exp=parsedData->insertExpression((Expression *)$3, (*(FunctionType *)$6), (Expression *)$5);
             $$=exp;
	}
        | DATE_SUB '(' atom  INTERVAL atom date_opt ')'
        {
             Expression* exp;
             //parsedData->setFunctionType((*(FunctionType *)$6));
             parsedData->setFunctionType((FunctionType)((int)(*(FunctionType *)$6)+3));
             exp=parsedData->insertExpression((Expression *)$3, (FunctionType)((int)(*(FunctionType *)$6)+3), (Expression *)$5);
             $$=exp;
        }
        | TIME_DIFF '(' atom ',' atom ')'
        {
              Expression* exp;
              parsedData->setFunctionType(TIMEDIFF);
              exp=parsedData->insertExpression((Expression *)$3, TIMEDIFF, (Expression *)$5);
            $$=exp;
        }
        | TIME_ADD '(' atom  INTERVAL atom time_opt ')'
        {
             Expression* exp;
             parsedData->setFunctionType((*(FunctionType *)$6));
             exp=parsedData->insertExpression((Expression *)$3, (*(FunctionType *)$6), (Expression *)$5);
             $$=exp;
        }
        | TIME_SUB '(' atom  INTERVAL atom time_opt ')'
        {
             Expression* exp;
             parsedData->setFunctionType((FunctionType)((int)(*(FunctionType *)$6)+3));
             exp=parsedData->insertExpression((Expression *)$3, (FunctionType)((int)(*(FunctionType *)$6)+3), (Expression *)$5);
             $$=exp;
        }
	| TIMESTAMP_DIFF '(' datetime_opt ','  atom ',' atom ')'
        {
              Expression* exp;
              int diff=0;
              FunctionType val = (*(FunctionType *)$3);
              if( val == DATEADDWITHYEAR || val == DATEADDWITHMON || val == DATEADDWITHDAY ) diff = 24;
              else diff = 21;
              parsedData->setFunctionType((FunctionType)((int)(*(FunctionType *)$3+diff)));
              exp=parsedData->insertExpression((Expression *)$5, (FunctionType)((int)(*(FunctionType *)$3)+diff), (Expression *)$7);
            $$=exp;
        }
        | TIMESTAMP_ADD '(' atom  INTERVAL atom datetime_opt ')'
        {
             Expression* exp;
             parsedData->setFunctionType((FunctionType)((int)(*(FunctionType *)$6)+12));
             exp=parsedData->insertExpression((Expression *)$3, (FunctionType)((int)(*(FunctionType *)$6)+12), (Expression *)$5);
             $$=exp;
        }
        | TIMESTAMP_SUB '(' atom  INTERVAL atom datetime_opt ')'
        {
             Expression* exp;
             parsedData->setFunctionType((FunctionType)((int)(*(FunctionType *)$6)+15));
             exp=parsedData->insertExpression((Expression *)$3, (FunctionType)((int)(*(FunctionType *)$6)+15), (Expression *)$5);
             $$=exp;
        }
        | EXTRACT '(' datetime_opt FROM atom ')'
	{
            FunctionType val = UNKNOWN_FUNCTION;
            //if((*(FunctionType *)$3) >=8)
              // val = (FunctionType)((int)(*(FunctionType *)$3)+36);
            //else
               val = (FunctionType)((int)(*(FunctionType *)$3)+30);
            Expression* exp;
            parsedData->setFunctionType(val);
            exp=parsedData->insertExpression((Expression *)$5, val,NULL);
            $$=exp;
	}
        ;
datetime_opt: time_opt
        {
           FunctionType val = *(FunctionType *)$1;
           $$ = &val;
        }
	| date_opt
        {
           FunctionType val = *(FunctionType *)$1;
           $$ = &val;
        }
	;
time_opt: HOUR 
	{ 
             FunctionType val = TIMEADDWITHHOUR;
             $$ = &val;
        }
	| MINUTE  
        {
             FunctionType val = TIMEADDWITHMIN;
             $$ = &val;
        }
	| SECOND  
        {
             FunctionType val = TIMEADDWITHSEC;
             $$ = &val;
        }
	;
date_opt: YEAR    
	{
	    FunctionType val = DATEADDWITHYEAR;
            $$ = &val;
	}
	| MONTH   
        {
	    FunctionType val = DATEADDWITHMON;
            $$ = &val;
        }
	| DAY  
        {
            FunctionType val = DATEADDWITHDAY;
            $$ = &val;
        }
	;
atom    :  ident
        {
            Expression* exp;
            exp=parsedData->insertExpression((char *)$1);
            free($1);
            $$=exp;
        }
        | value
        {
            Expression* exp;
            bool flag = false;
            exp=parsedData->insertExpression((char *)$1, flag);
            free($1);
            $$=exp;
        }
        | NULL_VALUE
        {
            Expression* exp;
            exp=parsedData->insertExpression("NULL");
            free($1);
            $$=exp;
        }
        ;

where_clause_opt:  WHERE conditions
        {
           parsedData->setCondition((Predicate*)$2);
        }
        |
        ;
group_by_opt:  GROUP BY group_field_list
        |
        ;
order_by_opt:  ORDER BY order_field_list
        |
        ;
limit_opt:  LIMIT NUMBER_STRING
        {
            parsedData->setLimit(atoi($2), 0);
        }
        | LIMIT NUMBER_STRING OFFSET NUMBER_STRING
        {
            parsedData->setLimit(atoi($2), atoi($4));
        }
        |
        ;
having_opt:  HAVING hconditions
        |
        ;
group_field_list: group_field_list group_field_list_L
        | group_field 
        ;
group_field_list_L: ',' group_field
        ;
group_field:   ident
        {
            parsedData->insertGroupField((char*)$1);
            free( $1 );
        }
        ;
order_field_list: order_field_list order_field_list_L
        | order_field
        ;
order_field_list_L: ',' order_field
        ;
order_field:   ident
        {
            parsedData->insertOrderByField((char*)$1);
            free( $1 );
        }
        | ident ASC
        {
            parsedData->insertOrderByField((char*)$1);
            free( $1 );
        }
        | ident DESC
        {
            parsedData->insertOrderByField((char*)$1, true);
            free( $1 );
        }
        ;
conditions: conditions OR conditions
	{
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpOr, (Predicate*) $3);
            //parsedData->setCondition((Predicate*)pred);
            $$= pred;

        }
        | conditions AND conditions
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpAnd, (Predicate*) $3);
            //parsedData->setCondition((Predicate*)pred);
            $$= pred;
        }
        | '(' conditions ')' { $$=$2; }
        | NOT '(' conditions ')'
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $3, OpNot, NULL);
            //parsedData->setCondition((Predicate*)pred);
            $$= pred;

        }
        | not_opt condition
        {
            if( $1 == (char*) 1 )
            {
                Predicate *pred;
                pred = parsedData->insertPredicate((Predicate*) $2, OpNot, NULL);
                //parsedData->setCondition((Predicate*)pred);
                $$= pred;
            }
            else
            {
                //parsedData->setCondition((Predicate*)$2);
                $$=$2;
            }
        }
        ;
hconditions: hconditions OR hconditions
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpOr, (Predicate*) $3);
            parsedData->setHavingCondition((Predicate*)pred);
            $$= pred;

        }
        | hconditions AND hconditions
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpAnd, (Predicate*) $3);
            parsedData->setHavingCondition((Predicate*)pred);
            $$= pred;
        }
        | '(' hconditions ')' { $$=$2; }
        | NOT '(' hconditions ')'
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $3, OpNot, NULL);
            parsedData->setHavingCondition((Predicate*)pred);
            $$= pred;

        }
        | not_opt hcondition
        {
            if( $1 == (char*) 1 )
            {
                Predicate *pred;
                pred = parsedData->insertPredicate((Predicate*) $2, OpNot, NULL);
                parsedData->setHavingCondition((Predicate*)pred);
                $$= pred;
            }
            else
            {
                parsedData->setHavingCondition((Predicate*)$2);
                $$=$2;
            }
        }
        ;
hcondition: MIN  '(' ident ')' OPERATOR value
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$5);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$3, (char*)$6, false, AGG_MIN, true);
            pred = parsedData->insertPredicate((char*) $3, op, ptr, AGG_MIN);
            free( $1 ); free ($3); free ($5); free ($6);
            $$=pred;
        }
        | MAX  '(' ident ')' OPERATOR value
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$5);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$3, (char*)$6, false, AGG_MAX, true);
            pred = parsedData->insertPredicate((char*) $3, op, ptr, AGG_MAX);
            free( $1 ); free ($3); free ($5); free ($6);
            $$=pred;
        }
        | SUM  '(' ident ')' OPERATOR value
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$5);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$3, (char*)$6, false, AGG_SUM, true);
            pred = parsedData->insertPredicate((char*) $3, op, ptr, AGG_SUM);
            free( $1 ); free ($3); free ($5); free ($6);
            $$=pred;
        }
        | AVG  '(' ident ')' OPERATOR value
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$5);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$3, (char*)$6, false, AGG_AVG, true);
            pred = parsedData->insertPredicate((char*) $3, op, ptr, AGG_AVG);
            free( $1 ); free ($3); free ($5); free ($6);
            $$=pred;
        }
        | COUNT  '(' ident ')' OPERATOR value
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$5);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$3, (char*)$6, false, AGG_COUNT, true);
            pred = parsedData->insertPredicate((char*) $3, op, ptr, AGG_COUNT);
            free( $1 ); free ($3); free ($5); free ($6);
            $$=pred;
        }
        ;

condition: ident OPERATOR value 
	{
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
			bool opLike = false;
            if (op == OpLike) {
                char *c = (char *)$3;
                //if (*c == '%' && *(c+1) == '\0')  
                Util::changeWildcardChar(c);
		opLike = true;
            }
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$3, opLike);
            pred = parsedData->insertPredicate((char*) $1, op, ptr);
            free( $1 ); free($2); free( $3 ); 
            $$=pred;
        }
        | ident OPERATOR ident
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            Predicate *pred;
            parsedData->insertCondValue((char*) $1);
            parsedData->insertCondValue((char*) $3);
            pred = parsedData->insertPredicate((char*) $1, op, (char*) $3);
            free( $1 ); free($2); free( $3 );
            $$=pred;
        }

        | ident not_opt BETWEEN value AND value
        {
            void **ptr1 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$4);
            void **ptr2 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$6);
            Predicate *finalPred;
 //           pred1 = parsedData->insertPredicate((char*) $1, OpGreaterThanEquals, ptr1);
//            pred2 = parsedData->insertPredicate((char*) $1, OpLessThanEquals, ptr2);
            finalPred = parsedData->insertBetPredicate((char*) $1, 
                        OpGreaterThanEquals, ptr1, OpLessThanEquals, ptr2);
                        //OpLessThanEquals, ptr2, OpGreaterThanEquals, ptr1);

            if( $2 == (char*) 1 )
                finalPred = parsedData->insertPredicate(finalPred, OpNot, NULL);
            free( $1 );  free( $4 );  free( $6 );
            $$= finalPred;
        }
        | ident not_opt IN '(' invalue_list ')'
        {
            ListIterator valIter = parsedData->getInValueList().getIterator();
            FieldValue *value1, *value2;
            Predicate *pred1, *pred2, *finalPred;
            void **ptr1, **ptr2;
            if (valIter.hasElement()) {
               value1 = (FieldValue*) valIter.nextElement();
               ptr1 = parsedData->insertCondValueAndGetPtr((char*)$1, value1->parsedString);
               pred1 = parsedData->insertPredicate((char*) $1, OpEquals, ptr1);
               finalPred=pred1;
            }
            while (valIter.hasElement()) {
               value2 = (FieldValue*) valIter.nextElement();
               ptr2 = parsedData->insertCondValueAndGetPtr((char*)$1, value2->parsedString);
               pred2 = parsedData->insertPredicate((char*) $1, OpEquals, ptr2);
               finalPred = parsedData->insertPredicate(pred1, OpOr, pred2);
               pred1= finalPred;     
            }
            if( $2 == (char*)1)
                finalPred = parsedData->insertPredicate(finalPred, OpNot, NULL);

            free( $1 );  
            $$= finalPred;
        }
        | ident IS NOT NULL_VALUE
        {
            Predicate *pred;
            parsedData->insertCondValue((char*) $1);
            pred = parsedData->insertNullPredicate((char*) $1, OpIsNull, false);
            free( $1 ); free($2); free( $3 );
            $$=pred;  
        }
        | ident IS NULL_VALUE
        {
            Predicate *pred;
            parsedData->insertCondValue((char*) $1);
            pred = parsedData->insertNullPredicate((char*) $1, OpIsNull, true);
            free( $1 ); free($2); free( $3 );
            $$=pred;  
        }
        | function_opt OPERATOR function_opt
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            Predicate *pred;
            pred = parsedData->insertPredicate(((Expression*)$1), op, ((Expression*)$3));
            $$=pred;
 
        }
        | function_opt OPERATOR ident
        {

            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            parsedData->insertCondValue((char*) $3);
            Predicate *pred;
            pred = parsedData->insertPredicate(((Expression*)$1), op, (char*) $3);
            $$=pred;
            
        }
        | function_opt OPERATOR value 
        {
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)"dummy", (char*)$3, false, AGG_UNKNOWN, false, true);
            Predicate *pred;
            pred = parsedData->insertPredicate(((Expression*)$1), op, ptr);
            $$=pred;
        }
        ;
not_opt: NOT
	{ $$=(char*) 1;
	}
	| 
	{ $$=(char*) 0; }
	;
table:   ident
        {
            parsedData->insertTableName((char*)$1);
            free( $1 );
        }
        | ident AS ident
        {
            parsedData->insertTableName((char*)$1, (char*)$3);
            free( $1 ); free($3);
        }
	| ident ident
	{
            parsedData->insertTableName((char*)$1, (char*)$2);
            free( $1 ); free($2);
        }
        ;
field:   ident
        {
            parsedData->insertField((char*)$1);
            free( $1 );
            
        }
        | MIN  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_MIN);
            free( $1 );
        }
        | MAX  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_MAX);
            free( $1 );
        }
        | SUM  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_SUM);
            free( $1 );
        }
        | AVG  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_AVG);
            free( $1 );
        }
        | COUNT  '(' ident ')'
        { 
            parsedData->insertField((char*)$3, AGG_COUNT);
            free( $1 );
        }
        | COUNT  '(' '*' ')'
        { 
            parsedData->insertField("*", AGG_COUNT);
            free( $1 );
        }
        | '*'
        { 
            parsedData->insertField("*");
        }
        |ident'*'
        {
            parsedData->insertField("*");
        }
        ;
ident:    FIELD { $$ = $1; }
	| '`'FIELD'`' { $$ = $2; }
        ;
value:    STRING { $$ = $1; }
        | num_value
        | BINARY_STRING { $$ = $1; }
        | doub_value
        | PARAMETER { $$ = $1; }
        | NULL_VALUE { $$ = (char*) 0; }
        ;
num_value: NUMBER_STRING { $$ =  $1; }
        | '-' NUMBER_STRING %prec UMINUS
        {
             char *n;
             n=(char*)malloc(30);
             strcpy(n,"-");
             strcat(n,(char*)$2);
             $$=n;
             free($2);
        }
        | '+' NUMBER_STRING %prec UMINUS{ $$ =  $2; }
        ;
doub_value : DOUBLE { $$ = $1; }
        | '-' DOUBLE %prec UMINUS
        {
             char *d;
             d=(char*)malloc(30);
             strcpy(d,"-");
             strcat(d,(char*)$2);
             $$=d;
             free($2);
        }
        | '+' DOUBLE %prec UMINUS{ $$ = $2; }
        ;
cache_statement: CACHE TABLE ident cache_opt semicolon_opt
        {
            if (!Conf::config.useCache())
            {
              printf("CACHE_TABLE is set to FALSE in csql.conf file.\n");
              free($3);
              YYABORT;
            }
            parsedData->setStmtType(CacheTableStatement);
            parsedData->setTableName($3); 
        }
        | UNCACHE TABLE ident semicolon_opt
        {
            parsedData->setStmtType(CacheTableStatement);
            parsedData->setUnCache(true);
            parsedData->setTableName($3); 
        }
        ; 
cache_opt: hcond_cache vcond_cache pk_cache direct_opt dsn_opt no_schema
         ;
hcond_cache: 
         | CONDITION value 
         {
            parsedData->setHCondFld(true);
            parsedData->setHCondition((char*)$2);
         }
         ;
vcond_cache:
         | FIELDLIST value
         {
            parsedData->setVCondFld(true);
            parsedData->setVCondition((char*)$2);
            free($2);
         }
         ;
pk_cache:
         | PK ident
         {
            parsedData->setPkFld(true);
            parsedData->setIndexName((char*)$2);
            free($2);
         }
         ;
direct_opt:
         | DIRECT
         {
            parsedData->setDirect(true);
         }
         ;
dsn_opt:
         | DSN value
         {
             parsedData->setDSN(true);
             parsedData->setPKTableName((char*)$2);
             free($2);
         }
no_schema:
         | NOSCHEMA
         {
             parsedData->setNoSchema(true);
         }
         ;
ddl_statement: CREATE TABLE ident '(' create_defn_list_con ')' semicolon_opt
        {
            parsedData->setStmtType(CreateTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | CREATE INDEX ident ON ident '(' field_list ')' opt_constr_type opt_ind_type opt_bucket semicolon_opt
        {
            parsedData->setStmtType(CreateIndexStatement);
            parsedData->setIndexName($3); 
            parsedData->setTableName($5); 
            free($3);
            free($5);
        }
        | DROP TABLE ident
        {
            parsedData->setStmtType(DropTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | DROP INDEX ident
        {
            parsedData->setStmtType(DropIndexStatement);
            parsedData->setIndexName($3); 
            free($3);
        }
        | TRUNCATE TABLE ident semicolon_opt
        {
            parsedData->setStmtType(TruncateStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        ;
opt_ind_type:
        | HASH  opt_constr_type
        {
            parsedData->setIndexType(hashIndex);
        }
        | TREE  opt_constr_type
        {
            parsedData->setIndexType(treeIndex);
        }
        |
        {
            parsedData->setIndexType(hashIndex);
        }
        ;
opt_constr_type:
        | UNIQUE 
        {
            parsedData->setUnique(true);
        }
        | PRIMARY 
        {
            parsedData->setUnique(true);
            parsedData->setPrimary(true);
        }
        |
        {
            parsedData->setUnique(false);
            parsedData->setPrimary(false);
        }
        ;
opt_bucket:
	| SIZE NUMBER_STRING
        {
            parsedData->setBucketSize(atoi($2));
            free($2);
        }
        ;
create_defn_list_con:create_defn_list
	|create_defn_list ',' constraint_defn
	;
create_defn_list: create_defn_list create_defn_list_L
        | create_defn
        ;

create_defn_list_L: ',' create_defn
        ;

create_defn: field_defn
        {
            parsedData->insertFldDef();
        }
        ;

field_defn: field_name field_type size_opt null_expr_opt default_expr_opt auto_increment_key 
        ;

field_name: ident
        {
            parsedData->setFldName($1);
            free($1);
        }
size_opt:
        | '(' NUMBER_STRING ')'
        {
            DbRetVal rv = parsedData->setFldLength(atoi($2));
            if (rv != OK) {
                yyerror("Binary field length < 256");
                free($2);
                YYABORT;
            }
            free($2);
        }
        ;

default_expr_opt:
        | DEFAULT value
        {
            DbRetVal rv = parsedData->setDefaultValue($2);
            if(rv != OK){
                yyerror("Invalid Default value.");
                free($2);
                YYABORT;
            }
            free($2);
        }
        ;

null_expr_opt:
        | NOT NULL_VALUE
        {
            parsedData->setFldNotNull(true);
        }
        ;
constraint_defn : primary_key_constraint
        | foreign_key_constraint
        | primary_key_constraint ',' foreign_key_constraint
        ;
foreign_key_constraint: foreign_key_constraint foreign_key_constraint_L
        | foreign_key_create
        ;
foreign_key_constraint_L: ',' foreign_key_create
        ;
foreign_key_create: FOREIGN KEY '(' fkField_list ')' REFERENCES ident'(' pkField_list ')'
        {
            parsedData->setForeign(true);
            parsedData->setPKTableName((char*)$7);
            parsedData->insertForeignKeyList();
        }
        ;
fkField_list: fkField_list fkField_list_L
        | fkField
        ;
fkField_list_L: ',' fkField
	;
fkField: ident
        {
           parsedData->insertFKField((char*)$1);
           free($1);
        }
        ;
pkField_list: pkField_list pkField_list_L
        | pkField
        ;
pkField_list_L: ',' pkField
        ;
pkField: ident
        {
           parsedData->insertPKField((char*)$1);
           free($1);
        }
        ;

primary_key_constraint: PRIMARY KEY '(' field_list ')' opt_bucket
        {
           parsedData->setPrimary(true);
        }
        ;
auto_increment_key:
        | AUTO_INCREMENT
        {
           DataType type = parsedData->getFldType();
           if(type > 4)
           {
               yyerror("AUTO_INCREMENT KEY can't be created other than INTEGER field ");
               free($1);
               YYABORT;
           }
           DbRetVal ret = parsedData->setAutoIncreament(true);
           if(ret != OK){
               yyerror("A table should have ony one AUTO_INCREMENT KEY ");
               free($1);
               YYABORT;
           }
           parsedData->setFldNotNull(true);
           parsedData->setAutoFldName(parsedData->getFldName());
           parsedData->setPrimary(true);
        }
        ;

field_type: INT_TYPE
        {
            parsedData->setFldType(typeInt);
        }
        | LONG_TYPE
        {
            parsedData->setFldType(typeLong);
        }
        | SHORT_TYPE
        {
            parsedData->setFldType(typeShort);
        }
        | BIGINT_TYPE
        {
            parsedData->setFldType(typeLongLong);
        }
        | TINYINT_TYPE
        {
            parsedData->setFldType(typeByteInt);
        }
        | FLOAT_TYPE
        {
            parsedData->setFldType(typeFloat);
        }
        | DOUBLE_TYPE
        {
            parsedData->setFldType(typeDouble);
        }
        ;
        | DATE_TYPE
        {
            parsedData->setFldType(typeDate);
        }
        ;
        | TIME_TYPE
        {
            parsedData->setFldType(typeTime);
        }
        ;
        | TIMESTAMP_TYPE
        {
            parsedData->setFldType(typeTimeStamp);
        }
        ;
        | CHAR_TYPE
        {
            parsedData->setFldType(typeString);
            parsedData->setFldLength(2);
        }
        ;
        | VARCHAR_TYPE
        {
            parsedData->setFldType(typeVarchar);
            parsedData->setFldLength(2);
        }
        ;
        | BINARY_TYPE
        {
            parsedData->setFldType(typeBinary);
            parsedData->setFldLength(1);
        }
        ;
%%

extern int lexEof;
void yyerror(const char* Msg) { 
    if( lexEof == 0 )
        fprintf(stderr, "[Parser: %s] %s\n", Msg, yytext);

    return;
}
