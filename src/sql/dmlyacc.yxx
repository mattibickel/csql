%{
#include <CSql.h>
#include <stdlib.h>
#include "Parser.h"

class Predicate;

ParsedData *parsedData;
extern char yytext[];
int yylex( void );
void yyerror(const char* Msg);
%}


%union
{
   char *stringval;
   void *predicate;
}

%token <stringval> STRING FIELD NUMBER_STRING BINARY_STRING DOUBLE OPERATOR PARAMETER
%token <stringval> SELECT FROM WHERE BETWEEN AND OR NOT
%token <stringval> STAR
%token <stringval> INSERT INTO VALUES
%token <stringval> DELETE UPDATE SET NULL_VALUE
%token <stringval> CREATE TABLE PRIMARY KEY DEFAULT INDEX ON HASH TREE UNIQUE DROP
%token <stringval> INT_TYPE LONG_TYPE SHORT_TYPE DOUBLE_TYPE TIMESTAMP_TYPE DATE_TYPE CHAR_TYPE TIME_TYPE
%token ';' ',' '(' ')'
%type <stringval> ident field value not_opt
%type <predicate> conditions condition

%%
command:  select_statement { YYACCEPT; }
        | insert_statement { YYACCEPT; }
        | delete_statement { YYACCEPT; }
        | update_statement { YYACCEPT; }
        | ddl_statement { YYACCEPT; }
        ;
        
select_statement: SELECT field_list FROM ident where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(SelectStatement);
            parsedData->setTableName($4); 
            free($4);
        }
        ;

field_list: field_list field_list_L
        | field 
        ;
field_list_L: ',' field
        ;
        
insert_statement: INSERT INTO ident field_list_opt VALUES '(' value_list ')' semicolon_opt
        {
            parsedData->setStmtType(InsertStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        ;

field_list_opt:
        | '(' field_list ')'
        ;

value_list: value_list value_list_L
        | value
	{
            parsedData->insertValue((char*)$1);
            free($1);
        }
        ;
value_list_L: ',' value 
	{
            parsedData->insertValue((char*)$2);
            free($2);
        }
        ;
        
delete_statement: DELETE FROM ident where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(DeleteStatement);
            parsedData->setTableName($3); 
            free($3);
	}
        ;
        
update_statement: UPDATE ident SET assign_list where_clause_opt semicolon_opt
	{
            parsedData->setStmtType(UpdateStatement);
            parsedData->setTableName($2); 
            free( $2 );
	}
        ;

semicolon_opt: ';'
        |
        ;

assign_list: assign_list assign_list_L
        | assign_stmt
        ;

assign_list_L: ',' assign_stmt
        ;
assign_stmt: ident OPERATOR value 
        { 
            parsedData->insertUpdateValue( (char*) $1, (char*) $3);
            free( $1 ); free( $3 ); 
        }
        ;
 
where_clause_opt:  WHERE conditions
        |
        ;

conditions: condition AND condition
	{
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpAnd, (Predicate*) $3);
            parsedData->setCondition((Predicate*)pred);
            $$= pred;

        }
        | condition OR condition
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $1, OpOr, (Predicate*) $3);
            parsedData->setCondition((Predicate*)pred);
            $$= pred;
        }
        | condition
        {
            parsedData->setCondition((Predicate*)$1);
            //((Predicate*)$1)->print();
            $$=$1;
        }
        ;
condition: ident OPERATOR value 
	{
            ComparisionOp  op = AllDataType::getComparisionOperator((char*)$2);
            Predicate *pred;
            void **ptr = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$3);
            pred = parsedData->insertPredicate((char*) $1, op, ptr);
            free( $1 ); free( $3 ); 
            $$=pred;
        }
        | ident not_opt BETWEEN value AND value
        {
            void **ptr1 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$4);
            void **ptr2 = parsedData->insertCondValueAndGetPtr((char*)$1, (char*)$6);
            Predicate *pred1, *pred2, *pred3, *finalPred;
            pred1 = parsedData->insertPredicate((char*) $1, OpGreaterThanEquals, ptr1);
            pred2 = parsedData->insertPredicate((char*) $1, OpLessThanEquals, ptr2);
            finalPred = parsedData->insertPredicate(pred1, OpAnd, pred2);
            if( $2 == (char*) 1 )
                finalPred = parsedData->insertPredicate(finalPred, OpNot, NULL);
            free( $1 );  free( $4 );  free( $6 );
            $$= finalPred;
        }
        | NOT condition
        {
            Predicate *pred;
            pred = parsedData->insertPredicate((Predicate*) $2, OpNot, NULL);
            $$= pred;
        }
        ;
not_opt: NOT
	{ $$=(char*) 1;
	}
	| 
	{ $$=(char*) 0; }
	;
field:   ident
        {
            parsedData->insertField((char*)$1);
            free( $1 );
        }
        | STAR
        { 
            parsedData->insertField((char*)$1);
            free( $1 );
        }
        ;
ident:    FIELD { $$ = $1; }
        ;
value:    STRING { $$ = $1; }
        | NUMBER_STRING { $$ = $1; }
        | BINARY_STRING { $$ = $1; }
        | DOUBLE { $$ = $1; }
        | PARAMETER { $$ = $1; }
        | NULL_VALUE { $$ = (char*) 0; }
        ;

ddl_statement: CREATE TABLE ident '(' create_defn_list ')' semicolon_opt
        {
            parsedData->setStmtType(CreateTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | CREATE INDEX ident ON ident '(' field_list ')' opt_constr_type opt_ind_type  semicolon_opt
        {
            parsedData->setStmtType(CreateIndexStatement);
            parsedData->setIndexName($3); 
            parsedData->setTableName($5); 
            free($3);
            free($5);
        }
        | DROP TABLE ident
        {
            parsedData->setStmtType(DropTableStatement);
            parsedData->setTableName($3); 
            free($3);
        }
        | DROP INDEX ident
        {
            parsedData->setStmtType(DropIndexStatement);
            parsedData->setIndexName($3); 
            free($3);
        }
        ;
opt_ind_type:
        | HASH 
        {
            parsedData->setIndexType(hashIndex);
        }
        | TREE 
        {
            parsedData->setIndexType(treeIndex);
        }
        |
        {
            parsedData->setIndexType(hashIndex);
        }
opt_constr_type:
        | UNIQUE 
        {
            parsedData->setUnique(true);
        }
        | PRIMARY 
        {
            parsedData->setUnique(true);
            parsedData->setPrimary(true);
        }
        |
        {
            parsedData->setUnique(false);
            parsedData->setPrimary(false);
        }
        ;
create_defn_list: create_defn_list create_defn_list_L
        | create_defn 
        ;

create_defn_list_L: ',' create_defn
        ;

create_defn: field_defn
        {
            parsedData->insertFldDef();
        }
        | constraint_defn
        ;

field_defn: field_name field_type size_opt null_expr_opt default_expr_opt
        ;

field_name: ident
        {
            parsedData->setFldName($1);
            free($1);
        }
size_opt:
        | '(' NUMBER_STRING ')'
        {
            parsedData->setFldLength(atoi($2));
            free($2);
        }
        ;

default_expr_opt:
        | DEFAULT value
        ;

null_expr_opt:
        | NOT NULL_VALUE
        {
            parsedData->setFldNotNull(true);
        }
        ;
constraint_defn: primary_key_constraint
        ;

primary_key_constraint: PRIMARY KEY '(' field_list ')'
        ;

field_type: INT_TYPE
        {
            parsedData->setFldType(typeInt);
        }
        | LONG_TYPE
        {
            parsedData->setFldType(typeLong);
        }
        | SHORT_TYPE
        {
            parsedData->setFldType(typeShort);
        }
        | BIGINT_TYPE
        {
            parsedData->setFldType(typeLongLong);
        }
        | FLOAT_TYPE
        {
            parsedData->setFldType(typeFloat);
        }
        | DOUBLE_TYPE
        {
            parsedData->setFldType(typeDouble);
        }
        ;
        | DATE_TYPE
        {
            parsedData->setFldType(typeDate);
        }
        ;
        | TIME_TYPE
        {
            parsedData->setFldType(typeTime);
        }
        ;
        | TIMESTAMP_TYPE
        {
            parsedData->setFldType(typeTimeStamp);
        }
        ;
        | CHAR_TYPE
        {
            parsedData->setFldType(typeString);
        }
        ;
%%

extern int lexEof;
void yyerror(const char* Msg) { 
    if( lexEof == 0 )
        fprintf(stderr, "[Parser: %s] %s\n", Msg, yytext);

    return;
}
