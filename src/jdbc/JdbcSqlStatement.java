package csql.jdbc;
import java.sql.Connection;
import java.sql.Statement;
import java.sql.SQLException;
import java.sql.ResultSet;
import java.sql.SQLWarning;

public class JdbcSqlStatement extends JSqlError implements Statement, JSqlErrorType
{
    public boolean closedFlag;
    public boolean isPrepared;
    public int rowsAffect;
    public JSqlStatement jniStmt;
    public JdbcSqlConnection conn;
    public JdbcSqlResultSet rs;
    public boolean isSelect;
    public boolean isFirstExecute;
    public int rowLimit;
    JdbcSqlStatement( Connection con )
    {
        jniStmt = new JSqlStatement();
        isFirstExecute = false;
        conn = (JdbcSqlConnection) con;  
        jniStmt.alloc(conn.mode);
        jniStmt.setConnectionPtr( conn.getConnection().getPtr() ); 
        closedFlag = false;
        isPrepared = false;
        rowsAffect = 0;
        isSelect = false;
        rs = new JdbcSqlResultSet();
    }
    protected void finalize ()
    {
        try
        {
            if(!closedFlag)
                close();
            jniStmt.free();//praba
        }
        catch(SQLException e)
        {
            System.out.println(e);
        }
    }
    public void prepareInt(String query) throws SQLException
    {
        int rv = 0;
        if(isPrepared) 
	{
            if(isSelect) rs.close();
            jniStmt.freeStmt();
            isPrepared = false;
            isFirstExecute = false;
            isSelect = false;
        }
        rv = jniStmt.prepare(query);
        if( rv != 0 ) // 0 ->OK
        {
            throw getException(CSQL_PREPARE_ERR);
        }
        isSelect = jniStmt.isSelect();
        isPrepared = true;
        isFirstExecute = true;
    }
    public boolean executeInt() throws SQLException
    {
        if (!isPrepared) throw getException(CSQL_NOT_PREPARED);
        rowsAffect = jniStmt.execute();
        if( rowsAffect < 0 )
            throw getException(CSQL_EXECUTE_ERR);
        if(conn.getAutoCommit())
            conn.commit();

        return(isSelect);
    }

    public void close() throws SQLException
    {
        if(closedFlag) return;
        if(isPrepared)
        {
            if(isSelect) rs.close();
            jniStmt.freeStmt();
            //jniStmt.free(); Praba. this makes the stmt unusable after close
        }
        closedFlag = true;
        return;
    }

    public void closeScan() throws SQLException
    {
        if(isSelect) jniStmt.close();
    }

    public boolean execute (String query) throws SQLException
    {
        prepareInt(query);
        return(executeInt());
    }

    public ResultSet executeQuery(String query) throws SQLException
    {
        prepareInt(query);
        if( !isSelect ) {
	    jniStmt.freeStmt();
            isPrepared = false;
            isFirstExecute = false;
            throw getException(CSQL_NOT_QUERY);
	}
	boolean hasResult = executeInt();

        rs.setStmt( this );
        rs.setProjField();
        return( rs );
    }
    public int executeUpdate (String query) throws SQLException
    {
        if(execute(query))
            throw getException(CSQL_NOT_UPDATE);
        return(rowsAffect);
    }
    public Connection getConnection() throws SQLException
    {
       return(conn);
    }
    public int getFetchDirection() throws SQLException
    {
        return(ResultSet.FETCH_FORWARD);
    }
    public int getFetchSize() throws SQLException
    {
        return 1;
    }
    public ResultSet getResultSet() throws SQLException
    {
        if(!isSelect)
            return (null);
         if(closedFlag) throw getException( CSQL_INVALID_STATE ); 
         rs.setStmt(this);
         return rs; 
    }
    public int getResultSetConcurrency() throws SQLException
    {
        return(ResultSet.CONCUR_READ_ONLY);
    }
    public int getResultSetHoldability() throws SQLException
    {
        return(ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    public int getResultSetType()  throws SQLException
    {
        return(ResultSet.TYPE_FORWARD_ONLY);
    }
    public int getUpdateCount() throws SQLException
    {
       // if(isSelect)
            return -1;
       // return rowsAffect;
    }


    //Unsupported APIs
    public void addBatch(String sql) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::addBatch called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void cancel() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::cancel called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void clearBatch() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::clearBatch called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void clearWarnings() throws SQLException
    {
        //TODO
        return;
    }
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::execute called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public boolean execute(String sql, int[] columnIndexes) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::execute called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public boolean execute(String sql, String[] columnNames) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::execute called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int[] executeBatch() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::executeBatch called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::executeUpdate called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::executeUpdate called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int executeUpdate(String sql, String[] columnNames) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::executeUpdate called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public ResultSet getGeneratedKeys() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::getGeneratedKeys called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int getMaxFieldSize() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::getMaxFieldSize called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int getMaxRows() throws SQLException
    {
        //TODO:
        return rowLimit;
        //if (JSqlError.isDebug) System.out.println("JdbcSqlStatement:;getMaxRows called"); 
        //throw getException(CSQL_NOT_SUPPORTED);
    }
    public boolean getMoreResults() throws SQLException
    {
//        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::getMoreResults called"); 
        //throw getException(CSQL_NOT_SUPPORTED);
        return false;
    }
    public boolean getMoreResults( int current) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::getMoreResults(int) called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public int getQueryTimeout() throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::getQueryTimeout called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public SQLWarning getWarnings() throws SQLException
    {
        //TODO information present in Action Item
        return null;
    }
    public void setCursorName(String name) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setCursorName called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setEscapeProcessing(boolean enable) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setEscapeProcessing called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setFetchDirection(int direction) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setFetchDirection called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setFetchSize(int rows) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setFetchSize called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setMaxFieldSize(int max) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setMaxFieldSize called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setMaxRows(int maxRows) throws SQLException
    {
       //TODO:
       rowLimit = maxRows; 
       // if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setMaxRows called"); 
        //throw getException(CSQL_NOT_SUPPORTED);
    }
    public void setQueryTimeout(int seconds) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::setQueryTimeout called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    //java 1.6 methods
    public boolean isPoolable() 
    {
        return false;
    }
    public void setPoolable(boolean pool) 
    {
        return;
    }
    public boolean isWrapperFor(Class ifact) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::isWrapperFor called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public Class unwrap(Class iface) throws SQLException
    {
        if (JSqlError.isDebug) System.out.println("JdbcSqlStatement::unwrap called"); 
        throw getException(CSQL_NOT_SUPPORTED);
    }
    public boolean isClosed() 
    {
        return closedFlag;
    }

}
